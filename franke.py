from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
import numpy as np
from random import random, seed

# Make data.
x = np.arange(0, 1, 0.05)
y = np.arange(0, 1, 0.05)
x, y = np.meshgrid(x,y)


def FrankeFunction(x,y):
    term1 = 0.75*np.exp(-(0.25*(9*x-2)**2) - 0.25*((9*y-2)**2))
    term2 = 0.75*np.exp(-((9*x+1)**2)/49.0 - 0.1*(9*y+1))
    term3 = 0.5*np.exp(-(9*x-7)**2/4.0 - 0.25*((9*y-3)**2))
    term4 = -0.2*np.exp(-(9*x-4)**2 - (9*y-7)**2)
    return term1 + term2 + term3 + term4


z = FrankeFunction(x, y)
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)

def R2(y_data, y_model):
    '''
    Calculate the R1 (coefficient of determinatoin) score for a regression model.

    Input:
    y_data (ndarray): The true value of the dependent variable.
    y_mode (ndarray): The predicted value of the dependent variable generated by the regression model.

    Output:
    R2 (float): The R2 score ranging from 0 to 1.
    '''
    return 1 - np.sum((y_data - y_model) ** 2) / np.sum((y_data - np.mean(y_data)) ** 2)

def MSE(y_data,y_model):
    '''
    Calculate the Mean Squared Error score for a regression model.

    Input:
    y_data (ndarray): The true value of the dependent variable.
    y_mode (ndarray): The predicted value of the dependent variable generated by the regression model.

    Output:
    MSE (float): The MSE score ranging from 0 to 1.
    '''
    n = np.size(y_model)
    return np.sum((y_data-y_model)**2)/n

p = 5 # polynomial degree
model = make_pipeline(PolynomialFeatures(degree=maxdegree), LinearRegression(fit_intercept=False))
clf = model.fit(x, y)